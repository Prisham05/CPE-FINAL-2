// Prisha Malhotra, Carter Eads, Katie Wagoner Final project

/*  Pin choices
   - Water sensor -> A0 (ADC channel 0)
   - Vent pot     -> A1 (ADC channel 1) [optional / not used]
   - DHT11        -> digital 51
   - LCD pins     -> RS=12, E=11, D4=5, D5=4, D6=3, D7=2
   - Stepper pins -> 23,27,25,29 (four-coil wiring)
   - Start button -> 19 (ISR)
   - Reset button -> 18 (polled)
   - Stepper open/close buttons -> digital 34 and 35 (polled with digitalRead)
   - Fan control -> digital 46 (PL3, low-side transistor)
   - LEDs
       Yellow -> PH0 = DISABLED
       Green  -> PH1 = IDLE
       Blue   -> PH6 = RUNNING
       Red    -> PJ0 = ERROR
*/
// ======================================================
// Final Project - Swamp Cooler
// Prisha Malhotra, Carter Eads, Katie Wagoner
//
// Description:
// Embedded swamp cooler controller with 4 system states:
// DISABLED, IDLE, RUNNING, ERROR
// Uses ADC (water), DHT11 (temp/humidity), RTC logging,
// stepper motor vent control, fan motor, LEDs, and ISR
// ======================================================

#include <dht.h>
#include <LiquidCrystal.h>
#include <RTClib.h>
#include <Stepper.h>

// ================= DHT11 SENSOR =================
#define DHTPIN 51
dht DHT;

// ================= LCD ==========================
const int RS = 12, E = 11, D4 = 5, D5 = 4, D6 = 3, D7 = 2;
LiquidCrystal lcd(RS, E, D4, D5, D6, D7);

// ================= RTC ==========================
RTC_DS1307 rtc;

// ================= STEPPER MOTOR =================
const int STEPS_PER_REV = 200;
Stepper stepper(STEPS_PER_REV, 23, 27, 25, 29);

// ================= ADC REGISTERS =================
volatile unsigned char* myADMUX  = (unsigned char*)0x7C;
volatile unsigned char* myADCSRB = (unsigned char*)0x7B;
volatile unsigned char* myADCSRA = (unsigned char*)0x7A;
volatile unsigned char* myADCL   = (unsigned char*)0x78;
volatile unsigned char* myADCH   = (unsigned char*)0x79;

// ================= LED REGISTERS =================
volatile unsigned char* myPORTH = (unsigned char*)0x0102;
volatile unsigned char* myDDRH  = (unsigned char*)0x0101;
volatile unsigned char* myPORTJ = (unsigned char*)0x0105;
volatile unsigned char* myDDRJ  = (unsigned char*)0x0104;

// LED bit assignments
#define LED_YELLOW_BIT 0   // DISABLED
#define LED_GREEN_BIT  1   // IDLE
#define LED_BLUE_BIT   6   // RUNNING
#define LED_RED_BIT    0   // ERROR (PORTJ)

// ================= BUTTONS ======================
#define START_BTN      19  // Start/Stop toggle (ISR)
#define RESET_BTN      18  // Reset button (polling)
#define VENT_OPEN_BTN  34
#define VENT_CLOSE_BTN 35

// ================= FAN MOTOR ====================
#define FAN_BIT 3  // PL3 -> pin 46
volatile unsigned char* myPORTL = (unsigned char*)0x10B;
volatile unsigned char* myDDRL  = (unsigned char*)0x10A;

// ================= SYSTEM STATES =================
enum State { DISABLED=0, IDLE=1, ERROR=2, RUNNING=3 };
volatile State systemState = DISABLED;

// Flags set by ISR or polling
volatile bool startPressedFlag = false;
volatile bool resetPressedFlag = false;

// ================= TIMING =======================
unsigned long lastLCDUpdateMs = 0;
const unsigned long LCD_INTERVAL_MS = 1000; // 1 second (allowed via millis)

// ================= THRESHOLDS ===================
const uint16_t WATER_THRESHOLD = 150;
const float TEMP_ON  = 23.0;
const float TEMP_OFF = 19.0;

// ================= STEPPER TRACKING ==============
int ventSteps = 0;

// ================= UART LOGGING ==================
void uart_init(unsigned long baud) {
  Serial.begin(baud);
}

// Logs state changes with timestamp (RTC)
void logEvent(const char* msg) {
  DateTime now = rtc.now();
  char s[120];
  snprintf(s, sizeof(s),
           "%04u/%02u/%02u %02u:%02u:%02u - %s",
           now.year(), now.month(), now.day(),
           now.hour(), now.minute(), now.second(),
           msg);
  Serial.println(s);
}

// ================= ADC FUNCTIONS =================
void adc_init() {
  *myADMUX |= (1<<6);            // AVcc reference
  *myADCSRA |= (1<<7);           // Enable ADC
  *myADCSRA |= (1<<2)|(1<<1)|(1<<0); // Prescaler = 128
}

uint16_t adc_read(uint8_t channel) {
  *myADMUX = (*myADMUX & 0xF0) | (channel & 0x0F);
  *myADCSRA |= (1<<6);           // Start conversion
  while(*myADCSRA & (1<<6));     // Wait
  return (*myADCH << 8) | *myADCL;
}

// ================= PIN INITIALIZATION ============
void pins_init() {
  *myDDRH |= (1<<LED_YELLOW_BIT)|(1<<LED_GREEN_BIT)|(1<<LED_BLUE_BIT);
  *myDDRJ |= (1<<LED_RED_BIT);
  *myDDRL |= (1<<FAN_BIT);

  pinMode(START_BTN, INPUT_PULLUP);
  pinMode(RESET_BTN, INPUT_PULLUP);
  pinMode(VENT_OPEN_BTN, INPUT_PULLUP);
  pinMode(VENT_CLOSE_BTN, INPUT_PULLUP);
}

// ================= LED CONTROL ===================
void setLED(State s) {
  *myPORTH &= ~((1<<LED_YELLOW_BIT)|(1<<LED_GREEN_BIT)|(1<<LED_BLUE_BIT));
  *myPORTJ &= ~(1<<LED_RED_BIT);

  if (s == DISABLED) *myPORTH |= (1<<LED_YELLOW_BIT);
  else if (s == IDLE) *myPORTH |= (1<<LED_GREEN_BIT);
  else if (s == RUNNING) *myPORTH |= (1<<LED_BLUE_BIT);
  else if (s == ERROR) *myPORTJ |= (1<<LED_RED_BIT);
}

// ================= FAN CONTROL ===================
void fanOn()  { *myPORTL |=  (1<<FAN_BIT); }
void fanOff() { *myPORTL &= ~(1<<FAN_BIT); }

// ================= VENT CONTROL ==================
void handleVentControl() {
  if (digitalRead(VENT_OPEN_BTN) && ventSteps < 100) {
    stepper.setSpeed(50);
    stepper.step(10);
    ventSteps += 10;
    logEvent("Vent opened");
  }
  else if (digitalRead(VENT_CLOSE_BTN) && ventSteps > 0) {
    stepper.setSpeed(50);
    stepper.step(-10);
    ventSteps -= 10;
    logEvent("Vent closed");
  }
}

// ================= ISR ===========================
// Start/Stop toggle button (pin 19)
void startISR() {
  startPressedFlag = true;
}

// ================= SETUP =========================
void setup() {
  lcd.begin(16,2);
  rtc.begin();
  adc_init();
  pins_init();
  uart_init(9600);

  systemState = DISABLED;
  setLED(systemState);

  lcd.print("Swamp Cooler");
  lcd.setCursor(0,1);
  lcd.print("State: DISABLED");

  logEvent("System boot - DISABLED");

  // Start button ISR
  attachInterrupt(digitalPinToInterrupt(START_BTN), startISR, FALLING);
}

// ================= MAIN LOOP =====================
void loop() {
  unsigned long now = millis();

  // ===== RESET BUTTON (ERROR -> IDLE) =====
  if (!digitalRead(RESET_BTN) && systemState == ERROR) {
    uint16_t water = adc_read(0);
    if (water >= WATER_THRESHOLD) {
      systemState = IDLE;
      lcd.clear();
      lcd.print("State: IDLE");
      logEvent("Reset -> IDLE");
    }
  }

  // ===== SENSOR MONITORING (NOT DISABLED) =====
  if (systemState != DISABLED) {
    uint16_t water = adc_read(0);

    if (water < WATER_THRESHOLD) {
      systemState = ERROR;
      fanOff();
      lcd.clear();
      lcd.print("ERROR: Low Water");
      logEvent("ERROR: Water low");
    }

    DHT.read11(DHTPIN);
    float temp = DHT.temperature;
    float hum  = DHT.humidity;

    // LCD update using millis()
    if (now - lastLCDUpdateMs >= LCD_INTERVAL_MS) {
      lastLCDUpdateMs = now;
      lcd.clear();
      lcd.print("T:");
      lcd.print(temp);
      lcd.print(" H:");
      lcd.print(hum);
      lcd.setCursor(0,1);
      lcd.print(systemState == RUNNING ? "RUNNING" : "IDLE");
    }

    // ===== STATE TRANSITIONS =====
    if (temp >= TEMP_ON && water >= WATER_THRESHOLD) {
      systemState = RUNNING;
      fanOn();
      logEvent("RUNNING: Fan ON");
    }
    else if (temp < TEMP_OFF) {
      systemState = IDLE;
      fanOff();
      logEvent("IDLE: Fan OFF");
    }

    handleVentControl();
  }

  // ===== START / STOP TOGGLE BUTTON =====
  if (startPressedFlag) {
    startPressedFlag = false;

    if (systemState == DISABLED) {
      systemState = IDLE;
      lcd.clear();
      lcd.print("State: IDLE");
      logEvent("Start pressed -> IDLE");
    } else {
      systemState = DISABLED;
      fanOff();
      lcd.clear();
      lcd.print("State: DISABLED");
      logEvent("Stop pressed -> DISABLED");
    }
  }

  setLED(systemState);
}

